def unix_match(filename: str, pattern: str) -> bool:
    """
    Ваша задача - определить, соответствует ли заданное имя файла заданному поисковому паттерну.
    Вот небольшая таблица, которая показывает, какие символы могут использовать в паттернах.
        [паттерн] соответствует любому символу в квадратных скобках, например [123] означает - любой символ из набора "123"
        [!паттерн] соответствует любому символу, кроме тех, что находятся в квадратных скобках, например [!123] означает - любой символ кроме "1", "2" и "3"
        [] Обратите внимание, что выражение в одной паре квадратных скобок отвечает только за 1 символ. То есть, ('0123', '[!abc]123') == True, но ('00123', '[!abc]123') = False
    Пример:
        unix_match('somefile.txt', 'somefile.txt') == True
        unix_match('1name.txt', '[!abc]name.txt') == True
        unix_match('log1.txt', 'log[1234567890].txt') == True
    """
    if "[" in pattern and "]" in pattern and len(pattern) == 2:  # если есть открывающая и закрывающая скобка условий, и в них ничего не содержится
        return False  # ошибка
    elif filename == pattern:  # если они равные
        return True  # файл найден
    elif "[" in pattern and "]" in pattern:  # если есть открывающая и закрывающая скобка условий, и в них чтото содержится
        a = []  # пустой список, для рычагов проверки, полученного имени с определенным паттерном
        b = 0  # флаг особенных условий
        c = 0  # шагатель цикла вайл
        while c <= len(pattern)-1:  # пробежка по паттерну, от начала к концу
            if b == 1:  # если особенные условия, те которые в []
                d = str()  # пустая строка для записи условий в нутри квадратных скобок
                for i in range(c, len(pattern)):  # пробежка по паттерну от "с" до конца
                    if pattern[i] != "]":  # если здесь нету закрывающей квадратной скобки
                        d += pattern[i]  # добавить символ в строку "d"
                    else:  # если сдесь закрывающая квадратная скобка
                        break  # прервать цикл фор
                a.append("[" + d + "]")  # записываем рычаг
                c += 1 + len(d)  # повысить позицию
                b = 0  # закончилось особенное условие
            elif pattern[c] == "[":  # если есть открывающая скобка
                b = 1  # появилось особенное условие в квадратных скобках
                c += 1  # повысить позицию
            else:  # позиция не открывающая особых условий
                a += str(pattern[c])  # добавить символ
                c += 1  # повысить позицию
        e = str()  # пустая строка для формировки имени файла, чтобы проверить его на совпадение с паттерном
        if len(a) > len(filename):  # если паттерн подраземевается на больше символов чем в имени файла сейчас имеется
            return False  # файл не может быть найден
        for i in range(0, len(filename)):  # пробежка по имени файла
            for j in range(0, len(a)):  # пробежка в количестве рычагов полученных с паттерна
                if len(a[j]) > 1:  #  если количество символов в рычаге привысило единицу, значит это особый рычаг с квадратных скобок
                    if a[j] == "[]":  # если условие пустое
                        return False  # файл не может быть найденным
                    elif "!" in a[j]:  # символ не должен быть в этом рычаге
                        if filename[i + j] not in a[j]:  # если этого символа нет в рычаге
                            e += a[j]  # записать рычаг целиком в "e"
                        else:  # символ попался
                            return False  # файл не найден
                    else:  # символ должен быть в рычаге
                        if filename[i + j] in a[j]:  # если этот символ есть в рычаге
                            e += a[j]  # записать рычаг целиком в "e"
                else:  # рычаг состоит из одного символа
                    e += a[j]  # записать символ рычага в "e"
            if e == pattern:  # если искомый файл нашелся
                return True  # файл найден
    elif "*" == pattern:  # если паттерн звезда
        return True  # файл найден
    else:  # ничего из выше указанного не сработало
        return False  # файл не найден


if __name__ == '__main__':
    print("Пример:")
    print(unix_match('1name.txt', '[!abc]name.txt'))
    print(unix_match('log1.txt', 'log[!0].txt'))
    print(unix_match("name.txt", "name[]txt"))
    print(unix_match("name.txt", "[!abc]name.txt"))
    print(unix_match('somefile.txt', '*'))
    print(unix_match("name.exe", "name.[!.][!.][!.]"))
    print(unix_match('log1.txt', 'log[!1].txt'))
    print(unix_match("name.txt", "[!abc]name.txt"))

    # Эти "asserts" используются только для самопроверки и не требуются для автоматического тестирования.
    assert unix_match('somefile.txt', 'somefile.txt') == True
    assert unix_match('1name.txt', '[!abc]name.txt') == True
    assert unix_match('log1.txt', 'log[!0].txt') == True
    assert unix_match('log1.txt', 'log[1234567890].txt') == True
    assert unix_match('log1.txt', 'log[!1].txt') == False
    assert unix_match("name.exe", "name.[!.][!.][!.]") == True
    assert unix_match("name.txt", "[!abc]name.txt") == False
    print("Кодирование завершено? Нажмите 'Check', чтобы получить отличные награды!")