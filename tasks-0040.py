"""
    Вам дается рифма (многострочная строка), в которой строки разделены «новой строкой» (\n).
    Регистр не имеет значения для вашего поиска, но перед поиском следует удалить пробелы.
    Вы должны найти слово внутри рифмы в горизонтальной (слева направо) или вертикальной
    (сверху вниз) линиях. Для этого вам нужно представить рифму в виде матрицы (2D-массива).
    Найдите координаты слова в отрезанном рифме (без пробелов).
    Результат должен быть представлен в виде списка -
    [начало строки, начало столбца, конец строки, конец столбца], где:
    - row_start - номер строки для первой буквы слова.
    - column_start - это номер столбца для первой буквы слова.
    - row_end - это номер строки для последней буквы слова.
    - column_end - номер столбца для последней буквы слова.
    Подсчет строк и столбцов начинается с 1.
"""


def checkio(text, word):
    a = text.replace(' ', '')  # Метод .replace() заменяет указанную фразу другой указанной фразой. (выкинуть пробелы).
    a = a.lower()  # все в нижний регистр
    a = a.split("\n")  # получаем список, количество значений которого == количество столбцов матрици
    for i in range(0, len(a)):  # пробежка по строкам матрицы
        if word.lower() in a[i]:  # если искомое слово здесь
            return [i+1, a[i].index(word)+1, i+1, a[i].index(word)+len(word)]  # выдать данные места положения слова
    # чтобы перевернуть матрицу нужно выровнять длину всех строк, найдем максимальную и с ней все остальные подровняем
    c = []  # пустой список для нахождения максимального количества символов среди всех строк
    for i in range(0, len(a)):  # пробежка по строкам матрици
        c.append(len(a[i]))  # регистрация количества символов в строках
    c = sorted(c)  # сортировка на возростание
    c = c[-1]  # количество строк при перевороте матрицы
    # уровнять длину строк
    b = [[]]*len(a)  # заготовка для переворота матрици
    for i in range(0, len(a)):  # пробежка по строкам
        if int(len(a[i])) < int(c):  # если в строке меньше символов чем в самой длинной
            b[i] = a[i]+"o"*(c-len(a[i]))  # создать пустые ячейки для столбцов в строке
        else:  # самая длинная строка
            b[i] = a[i]  # записываем еее без изменений
    # перевернуть матрицу
    d = [[]]*c  # создаем строки для перевернутой матрици
    for i in range(0, c):  # пробежка по строкам (#34)
        f = []  # пустой временный список для формировки и записи строки
        for k in range(0, len(b)):  # пробежка по строкам  (#8)
            f += b[k][i]  # заполнить ячейки значениями
        d[i] = f  # записать полученное в строку
    # конечный поиск
    for i in range(0, len(d)):  # пробежка по строкам перевернутой матрици
        g = "".join(d[i])
        if word.lower() in g:  # если искомое слово здесь
            return [g.index(word)+1, i+1, g.index(word)+len(word), i+1]  # выдать данные места положения слова


# Эти "asserts" используются только для самопроверки и не требуются для автоматического тестирования.
if __name__ == '__main__':
    assert checkio("""DREAMING of apples on a wall,
And dreaming often, dear,
I dreamed that, if I counted all,
-How many would appear?""", "ten") == [2, 14, 2, 16]
    assert checkio("""He took his vorpal sword in hand:
Long time the manxome foe he sought--
So rested he by the Tumtum tree,
And stood awhile in thought.
And as in uffish thought he stood,
The Jabberwock, with eyes of flame,
Came whiffling through the tulgey wood,
And burbled as it came!""", "noir") == [4, 16, 7, 16]
print("Кодирование завершено? Нажмите 'Check', чтобы получить отличные награды!")