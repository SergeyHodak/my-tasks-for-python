def frequency_sort(items):
    """
    Отсортируйте данный итератор таким образом, чтобы его элементы оказались
    в порядке убывания частоты их появления, то есть по количеству раз,
    которое они появляются в элементах. Если два элемента имеют одинаковую
    частоту, они должны оказаться в том же порядке,
    в котором стояли изначально в итераторе.
    """
    a = {}  # пустой словарь
    for i in range(0, len(items)):  # пробежка по списку
        if items[i] not in a:  # этой позиции нет в списке "a"
            a[items[i]] = items.count(items[i])  # добавить ключь со значением
    b = list(a.items())  # трансформация словаря в кортеж
    b = sorted(b, key=lambda x: x[1], reverse=True)  # сортировка кортежа на убывание по второму элементу
    c = []  # пустой список
    for i in range(0, len(b)):  # пробежка по кортежу "b"
        for j in range(0, b[i][1]):  # пробежка в зависимости от веса значения
            c.append(b[i][0])  # добавить ключ в список "c"
    return c  # выдать результат


if __name__ == '__main__':
    print("Пример:")
    print(frequency_sort([4, 6, 2, 2, 6, 4, 4, 4]))
    print(frequency_sort([4, 6, 2, 2, 2, 6, 4, 4, 4]))

    # Эти "assert" используются для самопроверки, а не для автоматического тестирования.
    assert list(frequency_sort([4, 6, 2, 2, 6, 4, 4, 4])) == [4, 4, 4, 4, 6, 6, 2, 2]
    assert list(frequency_sort(['bob', 'bob', 'carl', 'alex', 'bob'])) == ['bob', 'bob', 'bob', 'carl', 'alex']
    assert list(frequency_sort([17, 99, 42])) == [17, 99, 42]
    assert list(frequency_sort([])) == []
    assert list(frequency_sort([1])) == [1]
    print("Кодирование завершено? Нажмите 'Check', чтобы получить отличные награды!")