from typing import List


def sort_by_ext(files: List[str]) -> List[str]:
    """
    Вам предоставляется список файлов. Вам нужно отсортировать этот список по расширению файла.
    Файлы с одинаковым расширением следует отсортировать по имени.
    Некоторые возможные случаи:
        Имя файла не может быть пустой строкой;
        Файлы без расширения должны располагаться перед файлами с одним расширением;
        Имя файла «.config» имеет пустое расширение и имя «.config»;
        Имя файла "config." имеет пустое расширение и имя «config.»;
        Имя файла «table.imp.xls» имеет расширение «xls» и имя «table.imp»;
        Имя файла «.imp.xls» имеет расширение «xls» и имя «.imp».
    """
    # лямбда-функция
    skey = lambda s: (bool(s[:(i := s.rfind('.'))]), s[i + 1:], s[:i])  # приблизительное описание в имитации лямбда
    return sorted(files, key=skey)  # сортировка по ключу, ключ стает словом по очереди из files, и передается как s
    """
    # print((lambda x, y: x + y)(3, 3))  # (лямбда-функция, аргументы: действие над аргумаентами)(значение аргументов)

    # (имитация лямбда-функции)
    def outer_func(i):  # внешняя функция
        def inner_func(s):  # внутренняя функция
            # <<bool()>> возвращает True или False,  в данном случеи проверяется есть ли перед последней точкой чтото
            # <<s[:(i := s.rfind('.'))]>> имя файла[от начала до последней точки]
            # <<s.rfind('.')>> возвращает последний индекс, в котором находится подстрока 'точка'
            # <<s[i + 1:]>> кусок перед последней точкой, берет 'i' из 's.rfind('.')'
            # <<s[:i]>> кусок после последней точки, берет 'i' из 's.rfind('.')'
            return bool(s[:(i := s.rfind('.'))]), s[i + 1:], s[:i]  # описание пьятью строками выше
        return inner_func  # вызов внутренней функция
    skey = outer_func(range(0, len(files)))  # этот аргумент вызывает функцию, передавая ей диапазон пробежки (for)
    return sorted(files, key=skey)  # сорт по ключу. должно отправлять каждое слово на анализ, это и будет key= "s"
    """


if __name__ == '__main__':
    print("Пример:")
    print(sort_by_ext([".config", "my.doc", "1.exe", "345.bin", "green.bat", "format.c", "no.name.", "best.test.exe"]))

    assert sort_by_ext([".config", "my.doc", "1.exe", "345.bin", "green.bat", "format.c", "no.name.", "best.test.exe"]) == [".config", "no.name.", "green.bat", "345.bin", "format.c", "my.doc", "1.exe", "best.test.exe"]

    # Эти "asserts" используются только для самопроверки и не требуются для автоматического тестирования.
    assert sort_by_ext(['1.cad', '1.bat', '1.aa']) == ['1.aa', '1.bat', '1.cad']
    assert sort_by_ext(['1.cad', '1.bat', '1.aa', '2.bat']) == ['1.aa', '1.bat', '2.bat', '1.cad']
    assert sort_by_ext(['1.cad', '1.bat', '1.aa', '.bat']) == ['.bat', '1.aa', '1.bat', '1.cad']
    assert sort_by_ext(['1.cad', '1.bat', '.aa', '.bat']) == ['.aa', '.bat', '1.bat', '1.cad']
    assert sort_by_ext(['1.cad', '1.', '1.aa']) == ['1.', '1.aa', '1.cad']
    assert sort_by_ext(['1.cad', '1.bat', '1.aa', '1.aa.doc']) == ['1.aa', '1.bat', '1.cad', '1.aa.doc']
    assert sort_by_ext(['1.cad', '1.bat', '1.aa', '.aa.doc']) == ['1.aa', '1.bat', '1.cad', '.aa.doc']
    print("Кодирование завершено? Нажмите 'Check', чтобы получить отличные награды!")


# мое первое решение этой задачи
"""b = []  # пустой список для файлов без расширения
    c = []  # пустой список для файлов c именем и расширением
    for i in range(0, len(files)):  # пробежка по именам файлов
        a = files[i].split(".")  # разбить имя по разделителю точка
        if len(a) == 1:  # если мы получили только один фрагмент
            b += [files[i]]  # добавляем в список файлов без расширения
        elif len(a) == 2:  # если получили два фрагмента
            if a[0] == "" or a[1] == "":  # если хотябы один фрагмет пустой
                b += [files[i]]  # добавляем в список файлов без расширения
            else:  # фрагменты не пустые
                c += [[a[0]+str("."), a[1]]]  # добавить имя + расширение
        elif len(a) >= 3:  # если получили три фрагмента или больше
            d = files[i].index(".", files[i].index(".") + files[i].count("."))  # возвращает позицию (индекс) последней точки в названии
            if files[i][d+1:].isalpha():  # если после последней точки имеются только буквы
                c += [[files[i][0:d+1], files[i][d+1:]]]  # добавить имя + расширение
            else:  # после последней точки походу пусто
                b += [files[i]]  # добавляем в список файлов без расширения
    b = sorted(b)  # сортирует по алфавиту
    e = []  # пустой список для подсчета повторений расширений
    for j in range(0, len(c)):  # пробежка по образовавшемуся списку "c"
        e += [c[j][1]]  # список из расширений
    w = e  # согханяет количество повторений для его анализа
    e = list(set(e))  # удаляет повторения
    e = sorted(e)  # сортирует по алфавиту
    q = []  # пустой список для сортировки по расширению
    for f in range(0, len(e)):  # пробежка по образовавшемуся списку "e"
        q += [[e[f], w.count(e[f])]]  # расширение + количество его повторений
    r = []  # пустой список на выдачу
    for i in range(0, len(e)):  # пробежка по образовавшемуся списку "e"
        if q[i][1] == 1:  # если у этого расширения 1 повторение
            for j in range(0, len(c)):  # пробежка по списку с
                if c[j][1] == q[i][0]:  # если расширение из списка "c" равное расширению из списка "q"
                    r += [c[j][0]+c[j][1]]  # добавляем его в список на выдачу
        else:  # у этого расширения 2 и более повторений
            t = []  # временный пустой список для сортировки названий с одинаковым расширением
            for j in range(0, len(c)):  # пробежка по списку с
                if c[j][1] == q[i][0]:  # если расширение из списка "c" равное расширению из списка "q"
                    t += [c[j][0] + c[j][1]]  # добавляем его в временной для сортировки
            t = sorted(t)  # сортировка одно расширных файлов
            r += t  # добавления результата на выдачу
    return b+r  # выдаем полученные результаты"""