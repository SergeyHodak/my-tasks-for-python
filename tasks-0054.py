# 135.  Solve It (+15 points)
"""
    Ваша задача восстановить баланс открытых и закрытых скобок методом удаления ненужных,
    при этом использовать нужно минимальное количеством удалений.
    В переданной строке могут использоваться только 3 типа скобок (), [] и {}.
    Круглую скобку может закрывать только круглая скобка. Т.е. в этом выражении "(}" - баланса скобок нет.
    В пустой строке, т.е. в строке не содержащей ни одной скобки - баланс скобок есть,
    но при этом удаление всех скобок не является оптимальным решением.
    Если правильных ответа больше одного, то выбран должен быть тот, у которого первый убираемый символ
    находится ближе к началу. Например для варианта "[(])" правильным ответом будет "()",
    т.к. убираемые квадратные скобки находятся ближе к началу строки
"""
def remove_brackets(line: str) -> str:
    def tip(simvol):  # подпрограмма опредиления типа символа
        if simvol in "([{":  # если этот симол среди открывающихся
            return "open"  # вернуть тип (открыто)
        else:  # этот символ попал в закрывающиеся скобки
            return "close"  # вернуть тип (закрыто)

    if len(line) == 0:  # если строка пуста
        return ""  # вернуть пустую строку
    for i in range(0, len(line)):  # пробежка
        if len(line) == line.count(line[i]):  # если строка состоит только и одного типа символов всего 6 типов "()[]{}"
            return ""  # вернуть пустую строку

    a = []  # типа база характеристик и позициях в виде кортежа
    for i in range(0, len(line)):  # пробежка
        a += [[i, line[i], tip(line[i])]]  # добавлять [позиция, скобка, тип]

    i = 0  # шагатель
    k1 = 0  # для маркера со скобкой (
    k2 = 0  # для маркера со скобкой [
    k3 = 0  # для маркера со скобкой {
    while i < len(a):  # пробежка
        if ["(", "open"] == a[i][1:]:  # если эта позиция в кортеже равна открывающейся круглой скобке
            k1 += 1  # добавть метку
            i += 1  # повысить шагатель
        elif [")", "close"] == a[i][1:]:  # если эта позиция кортежа равна закрывающейся круглой скобке
            for j in reversed(a[:i]):  # пробежка по куску от этой закрывающейся скобки к началу
                if ["(", "open"] == j[1:]:  # если эта позиция равна ближайшей открывающей скобки данного типа
                    a[j[0]][2] = "on"  # изменить тип открывающей
                    a[i][2] = "on"  # изменить тип закрывающей
                    k1 -= 1  # убрать метку
                    i += 1  # повысить шагатель
                    break  # прервать цикл фор
        elif ["[", "open"] == a[i][1:]:  # если эта позиция в кортеже равна открывающейся квадратной скобке
            k2 += 1  # добавть метку
            i += 1  # повысить шагатель
        elif ["]", "close"] == a[i][1:]:  # если эта позиция кортежа равна закрывающейся квадратной скобке
            for j in reversed(a[:i]):  # пробежка по куску от этой закрывающейся скобки к началу
                if ["[", "open"] == j[1:]:  # если эта позиция равна ближайшей открывающей скобки данного типа
                    a[j[0]][2] = "on"  # изменить тип открывающей
                    a[i][2] = "on"  # изменить тип закрывающей
                    k2 -= 1  # убрать метку
                    i += 1  # повысить шагатель
                    break  # прервать цикл фор
        elif ["{", "open"] == a[i][1:]:  # если эта позиция в кортеже равна открывающейся фигурной скобке
            k3 += 1  # добавть метку
            i += 1  # повысить шагатель
        elif ["}", "close"] == a[i][1:]:  # если эта позиция кортежа равна закрывающейся фигурной скобке
            for j in reversed(a[:i]):  # пробежка по куску от этой закрывающейся скобки к началу
                if ["{", "open"] == j[1:]:  # если эта позиция равна ближайшей открывающей скобки данного типа
                    a[j[0]][2] = "on"  # изменить тип открывающей
                    a[i][2] = "on"  # изменить тип закрывающей
                    k3 -= 1  # убрать метку
                    i += 1  # повысить шагатель
                    break  # прервать цикл фор

    b = ""  # пустой список для вывода результата
    for i in range(0, len(a)):  # пробежка
        if a[i][2] == "on":  # если позиция активна
            b = b + str(a[i][1])  # саписать позицию
    return b  # выдать результат


    """i = 0  # шагатель
    a = ""  # строка для вывода
    b = ""  # временная база, строка
    while i < len(line):  # прибежка
        if line[i] == "(":  # если в позиции эта скобка
            b = b + "("
            i += 1
        elif line[i] == "[":  # если в позиции эта скобка
            b = b + "[(]"
            i += 1
        elif line[i] == "{":  # если в позиции эта скобка
            b = b + "{"
            i += 1
        elif line[i] == ")":  # если в позиции эта скобка
            b = b + ")"
            i += 1
        elif line[i] == "]":  # если в позиции эта скобка
            b = b + "]"
            i += 1
        elif line[i] == "}":  # если в позиции эта скобка
            b = b + "}"
            i += 1
    return b
    """
    """
    def opr(i, s1, s2, s3, g1, g2, g3):  # i == line[i]. Подфункция определиния открывающейся скобки
        if i == "(":  # откррывающая
            s1 += 1  # взводим флаг
            g1 += 1  # повысить счетчик
            return i, s1, s2, s3, g1, g2, g3  # выдать результат
        if i == "[":  # откррывающая
            s2 += 1  # взводим флаг
            g2 += 1  # повысить счетчик
            return i, s1, s2, s3, g1, g2, g3  # выдать результат
        if i == "{":  # откррывающая
            s3 += 1  # взводим флаг
            g3 += 1  # повысить счетчик
            return i, s1, s2, s3, g1, g2, g3  # выдать результат

    a = str()  # пустая строка
    s1 = 0  # "(" наличие открывающей круглой скобки
    s2 = 0  # "[" наличие открывающей квадратной скобки
    s3 = 0  # "{" наличие открывающей фигурной скобки
    g1 = 0  # "(" наличие открывающей круглой скобки, счетчик
    g2 = 0  # "[" наличие открывающей квадратной скобки, счетчик
    g3 = 0  # "{" наличие открывающей фигурной скобки, счетчик
    for i in range(0, len(line)):  # пробежка по символам линии
        if s1 > 0 or s2 > 0 or s3 > 0:  # если есть хотябы один активный флаг
            if line[i] in "([{" and i != len(line)-1:  # если данная позиция открывающая и не последняя
                i, s1, s2, s3, g1, g2, g3 = opr(line[i], s1, s2, s3, g1, g2, g3)  # обращение к подфункции
            elif line[i] in ")]}" and i != len(line)-1:  # данная позиция не последняя и в ней запирающие
                if line[i] == ")":  # закывающая )
                    if s1 == 1 and g1 == 1 and s2 == 0 and s3 == 0:  # если и флаг и счетчик только оди раз открывались
                        a = str(a) + "()"  # записать скобки на вывод
                        print("a=", a)
                        s1 -= 1  # понизить флаг
                        g1 -= 1  # понизить счетчик
                    elif s1 == 2 and g1 == 2 and s2 == 0 and s3 == 0:  # две открывающиеся и одна закрывающаясь
                        if ")" not in line[i:]:  # если от позиции до конца больше не будет закрывающей
                            a = a + "()"  # записать скобки
                            s1 = 0  # обнулить флаг
                            g1 = 0  # обнулить счетчик
                        elif line[i+1] == ")":  # если следующая закрывающая
                            a = a + "(())"  # записать скобки
                            s1 = 0  # обнулить флаг
                            g1 = 0  # обнулить счетчик
                        elif line[i+1] == "(" and line[i+2] == ")" and ")" not in line[i+3:]:  # если следующие две позиции как отдельные скобки, и до конца строки нет закрывающей
                            a = a + "()()"  # записать скобки
                            s1 = 0  # обнулить флаг
                            g1 = 0  # обнулить счетчик
                elif line[i] == "]":  # закывающая ]
                    if s2 == 1 and g2 == 1 and s1 == 0 and s3 == 0:  # если здесь только одна открывающая была
                        a = a + "[]"  # записать скобки
                        s2 = 0  # обнулить флаг
                        g2 = 0  # обнулить счетчик
                    if s2 == 2 and g2 == 2 and s1 == 0 and s3 == 0:  # если две открывающиеся скобки подряд
                        if line[i+1] == "]":  # если следующая закрывающая
                            a = a + "[[]]"  # записать скобки
                            s2 = 0  # обнулить флаг
                            g2 = 0  # обнулить счетчик
                    if s2 == 2 and g2 == 2 and s1 == 1 and g1 == 1 and s3 == 0:  # если такая ситуация [[(_']']
                        if "]" in line[i+1:]:  # в следующей есть закрывающая
                            a = a + "[[]]"  # записать скоби
                            s2 = 0  # обнулить флаг
                            g2 = 0  # обнулить счетчик
                        else:  # если в следующей позиции нет закрывающей
                            a = a + "[]"  # записать скоби
                            s2 = 0  # обнулить флаг
                            g2 = 0  # обнулить счетчик
                elif line[i] == "}":  # закывающая }
                    if s3 == 1 and g3 == 1:
                        a = a + "{}"  # записать скоби
                        s3 = 0  # обнулить флаг
                        g3 = 0  # обнулить счетчик
            else:  # позиция последняя и вней как отпирающие так и запирающие скобки могут находится
                pass
        else:  # если флаги не возведены
            i, s1, s2, s3, g1, g2, g3 = opr(line[i], s1, s2, s3, g1, g2, g3)  # обращение к подфункции
    return a  # выдать результат
    """


if __name__ == '__main__':
    print("Пример:")
    print(remove_brackets('(()()'))

    # Эти "asserts" используются только для самопроверки и не требуются для автоматического тестирования.
    assert remove_brackets('(()()') == '()()'
    assert remove_brackets('[][[[') == '[]'
    assert remove_brackets('[[(}]]') == '[[]]'
    assert remove_brackets('[[{}()]]') == '[[{}()]]'
    assert remove_brackets('[[[[[[') == ''
    assert remove_brackets('[[[[}') == ''
    assert remove_brackets('') == ''
    assert remove_brackets('[(])') == '()'
    print("Кодирование завершено? Нажмите 'Check', чтобы получить отличные награды!")